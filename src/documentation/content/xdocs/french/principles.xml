<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "http://apache.org/forrest/dtd/document-v12.dtd">
<document xml:lang="fr"> 
  <header> 
    <title>Principes techniques</title> 
  </header> 
  <body>
	<warning>Vous utilisez <em>Mozilla</em> sous <em>Windows 98</em> ? Votez pour le <fork href="http://bugzilla.mozilla.org/show_bug.cgi?id=180112">Bug 180112</fork> !</warning>
	<section>      
	<title>L'analyseur morphologique</title>
	<p>Créons un fichier <code>src/java/gpl/pierrick/brihaye/aramorph/test/testdocs/ktAb.txt</code> dans lequel nous allons saisir un seul mot, <em>كتاب</em>.</p> 
	<p>Exécutons ensuite le code suivant :</p>
	<source>
java -cp build/ArabicAnalyzer.jar;lib/commons-collections.jar gpl.pierrick.brihaye.aramorph.AraMorph src/java/gpl/pierrick/brihaye/aramorph/test/testdocs/ktAb.txt CP1256 results.txt UTF-8 -v</source>
	<warning>Naturellement, l'encodage du fichier d'entrée doit être adapté à votre plate-forme.</warning>
	<p>Examinons le fichier de sortie <code>results.txt</code> qui est, lui, en <code>UTF-8</code> pour pouvoir bénéficier des possibilités de vocalisation :</p>
	<source>
Processing token : 	كتاب
Transliteration : 	ktAb
Token not yet processed.
Token has direct solutions.

SOLUTION #1
Lemma  : 	kitAb
Vocalized as : 	كِتاب
Morphology : 
	Prefix : Pref-0
	Stem : Ndu
	Suffix : Suff-0
Grammatical category : 
	Stem : kitAb/NOUN
Glossed as : 
	Stem : book


SOLUTION #3
Lemma  : 	kAtib
Vocalized as : 	كُتّاب
Morphology : 
	Prefix : Pref-0
	Stem : N
	Suffix : Suff-0
Grammatical category : 
	Stem : kut~Ab/NOUN
Glossed as : 
	Stem : authors/writers


SOLUTION #2
Lemma  : 	kut~Ab
Vocalized as : 	كُتّاب
Morphology : 
	Prefix : Pref-0
	Stem : N
	Suffix : Suff-0
Grammatical category : 
	Stem : kut~Ab/NOUN
Glossed as : 
	Stem : kuttab (village school)/Quran school
	</source>
	<p>Le fonctionnement de l'analyseur morphologique devient dès lors plus évident :</p>
	<table>
		<tr><th>Message</th><th>Signification</th></tr>
		<tr><td><code>Processing token</code></td><td>le mot actuellement traité</td></tr>
		<tr><td><code>Transliteration</code></td><td>la translitération du mot dans le système de <fork href="http://www.qamus.org/transliteration.htm"><em>Buckwalter</em></fork></td></tr>
		<tr><td><code>Token not yet processed.</code></td><td>indique que le mot n'a pas encore été analysé ; uniquement avec le paramètre <code>-v</code></td></tr>
		<tr><td><code>Token has direct solutions.</code></td>
			<td>
			indique que le mot est analysable dans son orthographe actuelle ; uniquement avec le paramètre <code>-v</code>.<br/>
			En effet, <em>AraMorph</em> est capable de considérer des orthographes alternatives comme un <em>ـه</em> final en lieu et place de <em>ـة</em> ou un <em>ـى</em> final en lieu et place de <em>ـي</em>...
			</td>
		</tr>
		<tr><td><code>SOLUTION</code></td>
			<td>indique chacune des solutions pour le mot. L'ordre d'affichage n'est pas signifiant.</td>
		</tr>	
		<tr><td><code>Lemma</code></td><td>indique l'identifant du lemme de la solution dans le <link href="site:dictionaries">dictionnaire</link>.</td></tr>	
		<tr><td><code>Vocalized as :</code></td><td>indique la vocalisation de la solution.</td></tr>
		<tr><td><code>Morphology :</code></td><td>indique la morphologie du préfixe, du radical et du suffixe de la solution.</td></tr>
		<tr><td><code>Grammatical category :</code></td><td>indique la catégorie grammaticale du préfixe, du radical et du suffixe de la solution.</td></tr>
		<tr><td><code>Glossed as :</code></td><td>indique une ou plusieurs traductions anglaises pour le préfixe, le radical et le suffixe de la solution.</td></tr>
	</table>
	<note>Les explications sur les indications de morphologie et de catégorie grammaticale sont disponibles dans la rubrique concernant les <link href="site:dictionaries">dictionnaires</link>.</note>
	</section>
	<section>      
	<title>Comment <em>AraMorph</em> parvient-il à proposer des solutions acceptables ?</title>	
	<p>Avant toute chose, il faut savoir que <em>AraMorph</em>, comme son ancêtre en <em>Perl</em>, travaille sur une <strong>translitération</strong> du mot arabe. Cette translitération utilise naturellement le système de <em>Buckwalter</em>. Ainsi, <em>كتاب</em> est transcrit en <em>ktAb</em> avant son analyse morphologique.</p>
	<fixme author="PB">Cette opération ne devrait pas être nécessaire car <em>Java</em> travaille <strong>nativement</strong> en <em>Unicode</em>. L'optimisation du code, qui permettrait de se passer de l'étape de translitération et donc de gagner de la performance, reste <link href="site:todo">à réaliser</link>.</fixme>
	<p>Ensuite, <em>AraMorph</em> utilise un algorithme de force brute pour <strong>décomposer</strong> le mot en une succession de préfixe, radical et préfixe <strong>possibles</strong> :</p>
	<table>
		<tr><th>préfixe</th><th>radical</th><th>suffixe</th></tr>
		<tr><td><code>ktAb</code></td><td><code>Ø</code></td><td>Ø</td></tr>
		<tr><td><code>ktA</code></td><td><code>b</code></td><td>Ø</td></tr>
		<tr><td><code>ktA</code></td><td><code>Ø</code></td><td>b</td></tr>
		<tr><td><code>kt</code></td><td><code>Ab</code></td><td>Ø</td></tr>
		<tr><td><code>kt</code></td><td><code>A</code></td><td>b</td></tr>
		<tr><td><code>kt</code></td><td><code>Ø</code></td><td>Ab</td></tr>
		<tr><td><code>k</code></td><td><code>tAb</code></td><td>Ø</td></tr>
		<tr><td><code>k</code></td><td><code>tA</code></td><td>b</td></tr>
		<tr><td><code>k</code></td><td><code>t</code></td><td>Ab</td></tr>
		<tr><td><code>k</code></td><td><code>Ø</code></td><td>tAb</td></tr>
		<tr><td><code>Ø</code></td><td><code>ktAb</code></td><td>Ø</td></tr>
		<tr><td><code>Ø</code></td><td><code>ktA</code></td><td>b</td></tr>
		<tr><td><code>Ø</code></td><td><code>kt</code></td><td>Ab</td></tr>
		<tr><td><code>Ø</code></td><td><code>k</code></td><td>tAb</td></tr>
		<tr><td><code>Ø</code></td><td><code>Ø</code></td><td>ktAb</td></tr>		
	</table>
	<p>Ensuite, <em>AraMorph</em> vérifie la présence de chacun des éléments dans des dictionnaires :</p>
	<ul>
		<li>le préfixe, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/dictPrefixes</code></li>	
		<li>le radical, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/dictStems</code></li>	
		<li>le suffixe, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/dictSuffixes</code></li>	
	</ul>
	<p>En cas de succès, <em>AraMorph</em> récupère l'information morphologique de chacun des éléments.</p>
	<note>Un préfixe ou un suffixe Ø sont morphologiquement <strong>signifiants</strong>.</note>
	<p>Le cas échéant, <em>AraMorph</em> vérifie ensuite si les morphologies de chacun des éléments sont compatibles entre elles en examinant des tables de correspondances licites :</p>
	<ul>		
		<li>entre le préfixe et le radical, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/tableAB</code></li>	
		<li>entre le préfixe et le suffixe, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/tableAC</code></li>	
		<li>entre le radical et le suffixe, dans <code>gpl/pierrick/brihaye/aramorph/dictionaries/tableBC</code></li>	
	</ul>
	<p>Une décomposition de mot pour laquelle :</p>
	<ol>
		<li>préfixe, radical <strong>et</strong> suffixe disposent d'une entrée de dictionnaire,</li>
		<li>préfixe, radical <strong>et</strong> suffixe sont morphologiquement compatibles entre eux,</li>
	</ol>
	<p>... <strong>est</strong> une solution. Pour <em>كتاب</em>, elle sont au nombre de trois.</p>	
	</section>
	<section>
		<title>L'analyseur arabe pour Lucene</title>
		<p>Exécutons le code suivant :</p>
		<source>
java -cp build/ArabicAnalyzer.jar;lib/commons-collections.jar;lib/lucene-20030909.jar gpl.pierrick.brihaye.aramorph.test.TestArabicAnalyzer src/java/gpl/pierrick/brihaye/aramorph/test/testdocs/ktAb.txt CP1256 results.txt UTF-8
		</source>		
		<warning>Naturellement, l'encodage du fichier d'entrée doit être adapté à votre plate-forme.</warning>
		<p>Examinons le fichier de sortie <code>results.txt</code> :</p>
		<source>
كِتاب	NOUN	[0-4]	1
كُتّاب	NOUN	[0-4]	0	
		</source>		
		<p>Le principe est donc le suivant : chaque <strong>radical</strong> pertinent retourne un 
			<fork href="http://jakarta.apache.org/lucene/docs/api/org/apache/lucene/analysis/Token.html"><em>token</em></fork> 
			au sens où l'entend Lucene. Ici apparaissent le texte du <em>token</em> 
			(<fork href="http://jakarta.apache.org/lucene/docs/api/org/apache/lucene/analysis/Token.html#termText()"><code>termText</code></fork>),
			sa position dans le flux d'entrée (<fork href="http://jakarta.apache.org/lucene/docs/api/org/apache/lucene/analysis/Token.html#startOffset()"><code>startOffset</code></fork> et 
			<fork href="http://jakarta.apache.org/lucene/docs/api/org/apache/lucene/analysis/Token.html#endOffset()"><code>endOffset</code></fork>)			
			et sa position relative para rapport au <em>token</em> précédent (<fork href="http://jakarta.apache.org/lucene/docs/api/org/apache/lucene/analysis/Token.html#getPositionIncrement()"><code>positionIncrement</code></fork>).</p>
		<p>Il faut en effet attirer l'attention sur le fait qu'un même mot arabe, parce qu'il est généralement réduit à son squelette consonnatique, donne souvent lieu à <strong>plusieurs</strong> <em>solutions</em>.</p>
		<fixme author="PB">Quand bien même le texte serait vocalisé, les voyelles ne sont malheureusement pas prises en compte pour lever les ambiguités d'analyse. La résolution de ce problème est <link href="site:todo">à l'étude</link>.</fixme>
		<note>Dans cet exemple, le texte des <em>tokens</em> est en arabe, mais pour des raisons de performance, il vaut sans doute mieux retourner des tokens transcrits selon le système de Buckwalter.</note>
		<warning>Dans cet exemple, et bien que <em>كتاب</em> ait 3 solutions, on ne retourne que 2 <em>tokens</em>. En effet, <em>كُتّاب</em> est présent par 2 fois, la première en tant que pluriel de <em>كاتب</em>, le seconde en tant que nom singulier valant pour <em>école coranique</em>.</warning>
	</section>
	<section>
		<title>L'analyseur anglais pour Lucene</title>
		<p>Exécutons le code suivant :</p>
		<source>
java -cp build/ArabicAnalyzer.jar;lib/commons-collections.jar;lib/lucene-20030909.jar gpl.pierrick.brihaye.aramorph.test.TestArabicGlosser src/java/gpl/pierrick/brihaye/aramorph/test/testdocs/ktAb.txt CP1256 results.txt
		</source>		
		<warning>Naturellement, l'encodage du fichier d'entrée doit être adapté à votre plate-forme.</warning>
		<p>Examinons le fichier de sortie <code>results.txt</code> :</p>
		<source>
book	word	[0-4]	1
kuttab	word	[0-4]	0
village	word	[0-4]	0
school	word	[0-4]	0
quran	word	[0-4]	0
school	word	[0-4]	0
authors	word	[0-4]	0
writers	word	[0-4]	0
		</source>		
		<p>Suite à rédiger</p>
	</section>
  </body>
</document>
